import numpy as np
import matplotlib.pyplot as plt

# --- Constants ---
N = 10  # Number of robots
L = 3.0  # Side of the arena [m]
T_tot = 1800.0  # Total simulation time [s]
dt = 0.05  # Time step [s]

# Robot properties
v_inf = 0.01  # Speed at infinite intensity [m/s]
v_0 = 0.1  # Speed in the absence of light [m/s]
I_c = 0.1  # Reference intensity [W/m^2]
I_0 = 1.0  # Intensity generated by a single robot [W/m^2]
r_0 = 0.3  # Characteristic distance for intensity [m]
tau = 1.0  # Correlation time for noise [s]

# Delays
delta_pos_steps = 5
delta_neg_steps = -5

# --- Configuration for Delays ---
# Easily adjustable parameter to set the number of robots with negative delay.
# The rest will have positive delay.
N_neg_delay = 9

# --- Initialize Delays ---
# Start with all robots having positive delay
delay_steps = np.full(N, delta_pos_steps, dtype=int)
# Assign negative delay to the first N_neg_delay robots
if N_neg_delay > 0:
    delay_steps[0:N_neg_delay] = delta_neg_steps

# --- Simulation Setup ---
n_steps = int(T_tot / dt)
max_delay_steps = max(abs(delta_pos_steps), abs(delta_neg_steps))

# --- State Arrays ---
# Store positions, orientations, and intensities for all robots at all times
# We need extra space for handling delays
positions = np.zeros((n_steps + max_delay_steps, N, 2))
orientations = np.zeros((n_steps + max_delay_steps, N))
intensities = np.zeros((n_steps + 2 * max_delay_steps, N))

# --- Initialization ---
# Start with a random configuration
np.random.seed(42)  # for reproducibility
positions[max_delay_steps - 1] = np.random.rand(N, 2) * L
orientations[max_delay_steps - 1] = np.random.rand(N) * 2 * np.pi


# --- Helper Functions ---
def apply_periodic_boundaries(pos):
    """Apply periodic boundary conditions to positions."""
    return pos % L


def calculate_intensity(current_pos):
    """Calculate the light intensity seen by each robot."""
    I = np.zeros(N)
    for n in range(N):
        # Calculate squared distances to all other robots
        # Handle periodic boundaries by checking all 9 images
        min_dist_sq = np.zeros(N)
        for j in range(N):
            if n == j:
                continue

            # Calculate distance vector considering periodic boundaries
            delta = current_pos[n] - current_pos[j]
            delta = np.array([d - L * np.round(d / L) for d in delta])
            min_dist_sq[j] = np.sum(delta**2)

        # Sum intensities from other robots
        I[n] = np.sum(I_0 * np.exp(-min_dist_sq[np.arange(N) != n] / r_0**2))
    return I


def calculate_velocity(I):
    """Calculate robot speed based on intensity."""
    return v_inf + (v_0 - v_inf) * np.exp(-I / I_c)


# --- Main Simulation Loop ---
print("Starting simulation...")
for i in range(max_delay_steps, n_steps + max_delay_steps):
    # Calculate intensity at the current step (i) based on positions at (i-1)
    intensities[i] = calculate_intensity(positions[i - 1])

    # Calculate velocity for each robot based on its specific delay
    v = np.zeros(N)
    for n in range(N):
        delayed_intensity_idx = i - delay_steps[n]
        v[n] = calculate_velocity(intensities[delayed_intensity_idx, n])

    # Update orientation with noise
    w_phi = np.random.normal(0, 1, N)
    orientations[i] = orientations[i - 1] + np.sqrt(2 * dt / tau) * w_phi

    # Update position
    dx = v * np.cos(orientations[i - 1]) * dt
    dy = v * np.sin(orientations[i - 1]) * dt
    positions[i] = positions[i - 1] + np.vstack((dx, dy)).T

    # Apply periodic boundary conditions
    positions[i] = apply_periodic_boundaries(positions[i])

print("Simulation finished.")

# --- Extract final results (discarding the initial buffer) ---
final_positions = positions[max_delay_steps:]
final_orientations = orientations[max_delay_steps:]

# --- Plotting ---

# Plot 1: Initial and Final Configurations
fig1, (ax1, ax2) = plt.subplots(1, 2, figsize=(12, 6))
plt.style.use("default")

# Initial configuration
initial_pos = final_positions[0]
ax1.plot(initial_pos[:, 0], initial_pos[:, 1], "bo", label="Initial", markersize=8)
ax1.set_title("Initial configuration")
ax1.set_xlabel("x (m)")
ax1.set_ylabel("y (m)")
ax1.set_xlim(0, L)
ax1.set_ylim(0, L)
ax1.set_aspect("equal", adjustable="box")
ax1.legend()
ax1.grid(True)

# Final configuration
final_pos = final_positions[-1]
ax2.plot(final_pos[:, 0], final_pos[:, 1], "ro", label="Final", markersize=8)
ax2.set_title("Final configuration")
ax2.set_xlabel("x (m)")
ax2.set_ylabel("y (m)")
ax2.set_xlim(0, L)
ax2.set_ylim(0, L)
ax2.set_aspect("equal", adjustable="box")
ax2.legend()
ax2.grid(True)

plt.savefig("part2_configurations.png")
plt.show()


# Plot 2: Trajectory of a unique robot
# We will plot the trajectory of the single negative delay robot as it's the unique one.
fig2, ax3 = plt.subplots(figsize=(8, 8))

if N_neg_delay == 1:
    robot_to_plot_idx = 0  # The first robot is the negative delay one
    robot_type = "negative"
elif N_neg_delay == N - 1:
    robot_to_plot_idx = N - 1  # The last robot is the positive delay one
    robot_type = "positive"
else:
    robot_to_plot_idx = 0  # Default to plotting robot 0
    robot_type = "positive" if delay_steps[0] > 0 else "negative"


pos_robot_traj = final_positions[:, robot_to_plot_idx, :]

# Prevent plotting lines across periodic boundaries
diffs = np.diff(pos_robot_traj, axis=0)
dist_sq = np.sum(diffs**2, axis=1)
jump_indices = np.where(dist_sq > (0.5 * L) ** 2)[0]

plot_trajectory = pos_robot_traj.copy()
# Insert NaNs to break the line plot at jumps
for idx in reversed(jump_indices):  # reverse to not mess up indices
    plot_trajectory = np.insert(plot_trajectory, idx + 1, np.nan, axis=0)

ax3.plot(
    plot_trajectory[:, 0],
    plot_trajectory[:, 1],
    "-",
    label=f"{robot_type.capitalize()} delay robot",
)
ax3.plot(pos_robot_traj[0, 0], pos_robot_traj[0, 1], "go", markersize=10, label="Start")
ax3.plot(pos_robot_traj[-1, 0], pos_robot_traj[-1, 1], "ro", markersize=10, label="End")

ax3.set_title(f"Trajectory of {robot_type} delay robot")
ax3.set_xlabel("x (m)")
ax3.set_ylabel("y (m)")
ax3.set_xlim(0, L)
ax3.set_ylim(0, L)
ax3.set_aspect("equal", adjustable="box")
ax3.legend()
ax3.grid(True)

plt.savefig("part2_trajectory.png")
plt.show()


# Plot 3: 2D Histogram of Exploration
fig3, ax4 = plt.subplots(figsize=(8, 8))
ax4.set_title("2D histogram: Area explored by all robots")
ax4.set_xlabel("x (m)")
ax4.set_ylabel("y (m)")
ax4.set_aspect("equal", adjustable="box")

# Reshape positions of all robots into a single list of (x, y) coordinates
all_x = final_positions[:, :, 0].flatten()
all_y = final_positions[:, :, 1].flatten()

# Create the 2D histogram
hist = ax4.hist2d(all_x, all_y, bins=50, cmap="viridis", range=[[0, L], [0, L]])
fig3.colorbar(hist[3], ax=ax4, label="Visits")

plt.savefig("part2_histogram.png")
plt.show()
